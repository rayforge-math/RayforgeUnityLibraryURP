// Kernels for the different depth pyramid chains
#pragma kernel DownsampleMin
#pragma kernel DownsampleMax

/** Source depth texture (previous mip level). */
Texture2D<float> _Source;

/** Destination texture (current mip level). */
RWTexture2D<float> _Dest;

/** * Parameters for the downsampling pass. 
 * Using uint2 to match the C# side and ensure proper alignment.
 */
cbuffer _DownsampleParams
{
    uint2 _SourceRes;
    uint2 _DestRes;
};

/**
 * @brief Gathers 4 depth samples from the source texture using a 2x2 neighborhood.
 * Clamps coordinates to the source resolution to handle odd-sized textures.
 */
float4 GatherSamples(uint2 id)
{
    uint2 base = id * 2;
    
    // Boundary protection for odd-sized source textures
    uint2 c00 = base;
    uint2 c10 = min(base + uint2(1, 0), _SourceRes - 1);
    uint2 c01 = min(base + uint2(0, 1), _SourceRes - 1);
    uint2 c11 = min(base + uint2(1, 1), _SourceRes - 1);

    float4 samples;
    samples.x = _Source[c00].r;
    samples.y = _Source[c10].r;
    samples.z = _Source[c01].r;
    samples.w = _Source[c11].r;
    return samples;
}

/**
 * @brief Downsamples by taking the minimum of 4 samples.
 * Used for the "Min" chain (backwards-conservative in Reversed-Z).
 */
[numthreads(8, 8, 1)]
void DownsampleMin(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _DestRes.x || id.y >= _DestRes.y)
        return;

    float4 samples = GatherSamples(id.xy);
    _Dest[id.xy] = min(min(samples.x, samples.y), min(samples.z, samples.w));
}

/**
 * @brief Downsamples by taking the maximum of 4 samples.
 * Used for the "Max" chain (conservative depth for occlusion/raymarching).
 */
[numthreads(8, 8, 1)]
void DownsampleMax(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _DestRes.x || id.y >= _DestRes.y)
        return;

    float4 samples = GatherSamples(id.xy);
    _Dest[id.xy] = max(max(samples.x, samples.y), max(samples.z, samples.w));
}