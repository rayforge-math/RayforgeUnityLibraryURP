#pragma kernel DownsampleHighZ

/**
 * @brief Returns the minimum value of all four components of a float4.
 * @param v Input vector.
 * @return Minimum of v.x, v.y, v.z and v.w.
 */
float Min4(float4 v);

/**
 * @brief Returns the maximum value of all four components of a float4.
 * @param v Input vector.
 * @return Maximum of v.x, v.y, v.z and v.w.
 */
float Max4(float4 v);

/** Source depth texture. */
Texture2D<float> _Source;

/** Destination Hi-Z texture. */
RWTexture2D<float> _Dest;

/**
 * @brief Parameters for the Hi-Z downsampling pass.
 *
 * @note This constant buffer is explicitly laid out to respect
 *       HLSL constant buffer packing rules (16-byte alignment).
 *
 *       Do NOT change the member order or add smaller types
 *       without considering alignment and padding.
 */
cbuffer _DownsampleHighZParams
{
    uint2 _SourceRes;
    uint2 _DestRes;
};

/**
 * @brief Downsamples the depth buffer by a factor of 2x2 to build a Hi-Z level.
 *
 * For each destination pixel, four corresponding source pixels are sampled.
 * Depending on the depth convention, either the minimum (reversed Z)
 * or maximum (regular Z) depth is written.
 *
 * @param id Dispatch thread ID corresponding to the destination pixel.
 */
[numthreads(8, 8, 1)]
void DownsampleHighZ(uint3 id : SV_DispatchThreadID)
{
    if (_DestRes.x <= id.x || _DestRes.y <= id.y)
        return;

    uint2 base = id.xy * 2;
    
    uint2 c00 = base;
    uint2 c10 = min(base + uint2(1, 0), _SourceRes - 1);
    uint2 c01 = min(base + uint2(0, 1), _SourceRes - 1);
    uint2 c11 = min(base + uint2(1, 1), _SourceRes - 1);

    float4 samples;
    samples.x = _Source[c00].r;
    samples.y = _Source[c10].r;
    samples.z = _Source[c01].r;
    samples.w = _Source[c11].r;

    float result;
    
    // Reversed-Z: nearer = larger value, so take the minimum
    result = Min4(samples);

    _Dest[id.xy] = result;
}

/**
 * @brief Computes the minimum of four scalar values packed in a float4.
 * @param v Input vector.
 * @return Minimum value.
 */
float Min4(float4 v)
{
    return min(min(v.x, v.y), min(v.z, v.w));
}

/**
 * @brief Computes the maximum of four scalar values packed in a float4.
 * @param v Input vector.
 * @return Maximum value.
 */
float Max4(float4 v)
{
    return max(max(v.x, v.y), max(v.z, v.w));
}